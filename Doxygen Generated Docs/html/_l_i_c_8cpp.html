<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vector Field Reconstruction: C:/Users/Mango/Downloads/Skeleton2017 (1) - Copy/Skeleton2017_new_zip - Copy/Skeleton2017/LIC.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vector Field Reconstruction
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_l_i_c_8cpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">LIC.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Handles LIC Texture Creation AND Vector Field Reconstruction Methods.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;windows.h&gt;</code><br />
<code>#include &quot;GL\include\GL.H&quot;</code><br />
<code>#include &quot;GL\include\glu.h&quot;</code><br />
<code>#include &quot;GL\include\glut.h&quot;</code><br />
<code>#include &quot;GL\include\glui.h&quot;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &quot;<a class="el" href="_reader_8h_source.html">Reader.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="structures_8h_source.html">structures.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="globals_8h_source.html">globals.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_skeleton_8h_source.html">Skeleton.h</a>&quot;</code><br />
<code>#include &lt;math.h&gt;</code><br />
</div>
<p><a href="_l_i_c_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a525335710b53cb064ca56b936120431e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a525335710b53cb064ca56b936120431e">_USE_MATH_DEFINES</a></td></tr>
<tr class="separator:a525335710b53cb064ca56b936120431e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acb7213fbb6217a949fb35df63fbd9f8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#acb7213fbb6217a949fb35df63fbd9f8c">lazy_seeding</a> ()</td></tr>
<tr class="memdesc:acb7213fbb6217a949fb35df63fbd9f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">uniform streamline seeding method that stops tracing the streamline when it gets too cloest to another streamline  <a href="_l_i_c_8cpp.html#acb7213fbb6217a949fb35df63fbd9f8c">More...</a><br /></td></tr>
<tr class="separator:acb7213fbb6217a949fb35df63fbd9f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4fa02fa864c18cfcdbb258b12dc6d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a0c4fa02fa864c18cfcdbb258b12dc6d4">get_vector_truth</a> (int xx, int yy, float &amp;vx, float &amp;vy)</td></tr>
<tr class="memdesc:a0c4fa02fa864c18cfcdbb258b12dc6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the values vx and vy of the vector field from the encoded texture array data_img and assign it to vx, vy input  <a href="_l_i_c_8cpp.html#a0c4fa02fa864c18cfcdbb258b12dc6d4">More...</a><br /></td></tr>
<tr class="separator:a0c4fa02fa864c18cfcdbb258b12dc6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7104e8c3b0a2062c3c6685d5bf6ce97a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a7104e8c3b0a2062c3c6685d5bf6ce97a">getAbsoluteDiff2Angles</a> (const double x, const double y)</td></tr>
<tr class="memdesc:a7104e8c3b0a2062c3c6685d5bf6ce97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute diff between two angles.  <a href="_l_i_c_8cpp.html#a7104e8c3b0a2062c3c6685d5bf6ce97a">More...</a><br /></td></tr>
<tr class="separator:a7104e8c3b0a2062c3c6685d5bf6ce97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230d5b4c351c593b74f50010d1e395e4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a230d5b4c351c593b74f50010d1e395e4">min_distance_to_all_steamlines</a> (float x, float y)</td></tr>
<tr class="memdesc:a230d5b4c351c593b74f50010d1e395e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the minimum distance between the current point and the nearest point's streamline  <a href="_l_i_c_8cpp.html#a230d5b4c351c593b74f50010d1e395e4">More...</a><br /></td></tr>
<tr class="separator:a230d5b4c351c593b74f50010d1e395e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574f648560e17a168c68829af4a8ae54"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a574f648560e17a168c68829af4a8ae54">bilinear_interpolate_scalar</a> (float q11, float q12, float q21, float q22, float x1, float x2, float y1, float y2, float x, float y)</td></tr>
<tr class="memdesc:a574f648560e17a168c68829af4a8ae54"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform bilinear interpolation  <a href="_l_i_c_8cpp.html#a574f648560e17a168c68829af4a8ae54">More...</a><br /></td></tr>
<tr class="separator:a574f648560e17a168c68829af4a8ae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701214e14bc05250fda7211e5717f361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a701214e14bc05250fda7211e5717f361">bilinear_interpolate_node</a> (<a class="el" href="structnode__main.html">node_main</a> *b_left, <a class="el" href="structnode__main.html">node_main</a> *b_right, <a class="el" href="structnode__main.html">node_main</a> *t_right, <a class="el" href="structnode__main.html">node_main</a> *t_left)</td></tr>
<tr class="memdesc:a701214e14bc05250fda7211e5717f361"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpolate the vx and vy values using four nodes. By adding the offset value to node b_left to get the interpolated x and y value and then the resulting interpolated vx and vy is assigned into node b_left.vx_offset and vy_offset the purpose of this function is to use bilinear interpolation to determine the vector value of the offset grid points  <a href="_l_i_c_8cpp.html#a701214e14bc05250fda7211e5717f361">More...</a><br /></td></tr>
<tr class="separator:a701214e14bc05250fda7211e5717f361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334c2c59d34641767e8b2977d615a996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a334c2c59d34641767e8b2977d615a996">gen_noise_tex</a> ()</td></tr>
<tr class="memdesc:a334c2c59d34641767e8b2977d615a996"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate the white noise texture for LIC generation  <a href="_l_i_c_8cpp.html#a334c2c59d34641767e8b2977d615a996">More...</a><br /></td></tr>
<tr class="separator:a334c2c59d34641767e8b2977d615a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87cae5571d56b451db2f2018d42b677"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#ac87cae5571d56b451db2f2018d42b677">min_distance_to_steamline</a> (float x, float y, std::vector&lt; <a class="el" href="structnode.html">node</a> &gt; *streamline)</td></tr>
<tr class="memdesc:ac87cae5571d56b451db2f2018d42b677"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the minimum distance to a specific streamline from a point x,y  <a href="_l_i_c_8cpp.html#ac87cae5571d56b451db2f2018d42b677">More...</a><br /></td></tr>
<tr class="separator:ac87cae5571d56b451db2f2018d42b677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f961c29f18e6578f3272738013ac9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a21f961c29f18e6578f3272738013ac9f">min_node_to_steamline</a> (float x, float y, std::vector&lt; <a class="el" href="structnode.html">node</a> &gt; *streamline)</td></tr>
<tr class="memdesc:a21f961c29f18e6578f3272738013ac9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the closest node to a specific streamline from a point  <a href="_l_i_c_8cpp.html#a21f961c29f18e6578f3272738013ac9f">More...</a><br /></td></tr>
<tr class="separator:a21f961c29f18e6578f3272738013ac9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edd5969d04f7427730ca11229696d49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a7edd5969d04f7427730ca11229696d49">interpolate_streamline_selective</a> (float xx, float yy, float &amp;vx, float &amp;vy, float radar)</td></tr>
<tr class="memdesc:a7edd5969d04f7427730ca11229696d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">reconstruct the vector value of the point (xx,yy) on the vector field by using the Selective Weighed Sum method, this method provides the most reliable reconstruction it first uses the nearest streamline node's vector value as the base, then it finds the next closest node and compare the vector value, if the difference is below the average threshold then it computes the weighted sum between two nodes, if the diff is too large then it discard the second node. The process is repeated untill all nodes within radar range is processed  <a href="_l_i_c_8cpp.html#a7edd5969d04f7427730ca11229696d49">More...</a><br /></td></tr>
<tr class="separator:a7edd5969d04f7427730ca11229696d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1281b52ebf50b61510faeec9030a32d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#ad1281b52ebf50b61510faeec9030a32d">interpolate_streamline</a> (float xx, float yy, float &amp;vx, float &amp;vy, float radar)</td></tr>
<tr class="memdesc:ad1281b52ebf50b61510faeec9030a32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">reconstruct the vector value of the point (xx,yy) on the vector field by using the Adaptive Weighed Sum method  <a href="_l_i_c_8cpp.html#ad1281b52ebf50b61510faeec9030a32d">More...</a><br /></td></tr>
<tr class="separator:ad1281b52ebf50b61510faeec9030a32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8315a9072863e2a64b9f77b1036d54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#aaa8315a9072863e2a64b9f77b1036d54">interpolate_streamline_adv</a> (float xx, float yy, float &amp;vx, float &amp;vy, float radar)</td></tr>
<tr class="memdesc:aaa8315a9072863e2a64b9f77b1036d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: figure out what this method does.  <a href="_l_i_c_8cpp.html#aaa8315a9072863e2a64b9f77b1036d54">More...</a><br /></td></tr>
<tr class="separator:aaa8315a9072863e2a64b9f77b1036d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13988a42b45be1a5cb4160c82965f26f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a13988a42b45be1a5cb4160c82965f26f">interpolate_streamline_simple</a> (float xx, float yy, float &amp;vx, float &amp;vy, float radar)</td></tr>
<tr class="memdesc:a13988a42b45be1a5cb4160c82965f26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">reconstruct the vector value of a point by doing a simple weighted sum of all nearby streamline points. This is the least accurate method  <a href="_l_i_c_8cpp.html#a13988a42b45be1a5cb4160c82965f26f">More...</a><br /></td></tr>
<tr class="separator:a13988a42b45be1a5cb4160c82965f26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb2e546816ead289f4c3616d84e4c38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#aaeb2e546816ead289f4c3616d84e4c38">get_nearest_streamline_node</a> (float xx, float yy)</td></tr>
<tr class="memdesc:aaeb2e546816ead289f4c3616d84e4c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nearest streamline node object, search through all streamlines.  <a href="_l_i_c_8cpp.html#aaeb2e546816ead289f4c3616d84e4c38">More...</a><br /></td></tr>
<tr class="separator:aaeb2e546816ead289f4c3616d84e4c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11e7e720b8967b5e5e3d65a07bb4ee8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#af11e7e720b8967b5e5e3d65a07bb4ee8">interpolate_streamline_raycast</a> (float xx, float yy, float &amp;vx, float &amp;vy, float radar)</td></tr>
<tr class="memdesc:af11e7e720b8967b5e5e3d65a07bb4ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">poor man's raycast implementation, only check four offset points from the desired vector field point. Not very effective  <a href="_l_i_c_8cpp.html#af11e7e720b8967b5e5e3d65a07bb4ee8">More...</a><br /></td></tr>
<tr class="separator:af11e7e720b8967b5e5e3d65a07bb4ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e812df5b7c609971288722b7bd2ea71"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structnode.html">node</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a6e812df5b7c609971288722b7bd2ea71">trace_streamline_custom</a> (int xx, int yy, float min_dis)</td></tr>
<tr class="memdesc:a6e812df5b7c609971288722b7bd2ea71"><td class="mdescLeft">&#160;</td><td class="mdescRight">trace the streamline based on the given point, will stop when it gets too close to another streamline  <a href="_l_i_c_8cpp.html#a6e812df5b7c609971288722b7bd2ea71">More...</a><br /></td></tr>
<tr class="separator:a6e812df5b7c609971288722b7bd2ea71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfb182730d63b03a08745835c5106d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#acdfb182730d63b03a08745835c5106d4">trace_streamline</a> (int xx, int yy, int enhance)</td></tr>
<tr class="memdesc:acdfb182730d63b03a08745835c5106d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">trace the streamlet to produce the LIC texture  <a href="_l_i_c_8cpp.html#acdfb182730d63b03a08745835c5106d4">More...</a><br /></td></tr>
<tr class="separator:acdfb182730d63b03a08745835c5106d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ee8e46d8503c2a0549b53e0ff561aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#ac2ee8e46d8503c2a0549b53e0ff561aa">init_grids</a> ()</td></tr>
<tr class="memdesc:ac2ee8e46d8503c2a0549b53e0ff561aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">main function for setting up critical values of the vector field reconstruction process It initializes average error values, the reconstructed vector field values, and begin the vector field construction process  <a href="_l_i_c_8cpp.html#ac2ee8e46d8503c2a0549b53e0ff561aa">More...</a><br /></td></tr>
<tr class="separator:ac2ee8e46d8503c2a0549b53e0ff561aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ef4a9db8b17caa2c8b6120134e8091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#ae7ef4a9db8b17caa2c8b6120134e8091">trace_streamline_old</a> (int xx, int yy)</td></tr>
<tr class="memdesc:ae7ef4a9db8b17caa2c8b6120134e8091"><td class="mdescLeft">&#160;</td><td class="mdescRight">obsolete LIC streamline tracing method  <a href="_l_i_c_8cpp.html#ae7ef4a9db8b17caa2c8b6120134e8091">More...</a><br /></td></tr>
<tr class="separator:ae7ef4a9db8b17caa2c8b6120134e8091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2300c2a0e0a396711be37f08d412eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#aa2300c2a0e0a396711be37f08d412eef">render_vec_img</a> (<a class="el" href="class_polyhedron.html">Polyhedron</a> *this_poly)</td></tr>
<tr class="memdesc:aa2300c2a0e0a396711be37f08d412eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">render the vector field onto a texture for scaling to 512x512  <a href="_l_i_c_8cpp.html#aa2300c2a0e0a396711be37f08d412eef">More...</a><br /></td></tr>
<tr class="separator:aa2300c2a0e0a396711be37f08d412eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257bc330e36ebc0af5866cfc0017799b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a257bc330e36ebc0af5866cfc0017799b">interpolate_grid</a> ()</td></tr>
<tr class="memdesc:a257bc330e36ebc0af5866cfc0017799b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the values of the interpolated grid based on the original grid  <a href="_l_i_c_8cpp.html#a257bc330e36ebc0af5866cfc0017799b">More...</a><br /></td></tr>
<tr class="separator:a257bc330e36ebc0af5866cfc0017799b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9f43e730b3672285d78352c0fd15d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a7c9f43e730b3672285d78352c0fd15d6">compute_LIC</a> (int enhance)</td></tr>
<tr class="memdesc:a7c9f43e730b3672285d78352c0fd15d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the LIC image  <a href="_l_i_c_8cpp.html#a7c9f43e730b3672285d78352c0fd15d6">More...</a><br /></td></tr>
<tr class="separator:a7c9f43e730b3672285d78352c0fd15d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad369ab96ebde4b09102c400562c9ada2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#ad369ab96ebde4b09102c400562c9ada2">v_diff_average</a> = 0</td></tr>
<tr class="memdesc:ad369ab96ebde4b09102c400562c9ada2"><td class="mdescLeft">&#160;</td><td class="mdescRight">trackers for average difference in vector values  <a href="_l_i_c_8cpp.html#ad369ab96ebde4b09102c400562c9ada2">More...</a><br /></td></tr>
<tr class="separator:ad369ab96ebde4b09102c400562c9ada2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dc64fa95d54b85644d5c92c38f6066"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a48dc64fa95d54b85644d5c92c38f6066">v_diff_counter</a> = 0</td></tr>
<tr class="separator:a48dc64fa95d54b85644d5c92c38f6066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afaee52a9e947535072c3a099af48ff"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a0afaee52a9e947535072c3a099af48ff">avg_angle_diff</a> = 0</td></tr>
<tr class="separator:a0afaee52a9e947535072c3a099af48ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e0b1ea070ec97ad7b40ac0d6037d6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a10e0b1ea070ec97ad7b40ac0d6037d6c">angle_diff_counter</a> = 0</td></tr>
<tr class="separator:a10e0b1ea070ec97ad7b40ac0d6037d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e12e73800927bbae62911d176354832"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8cpp.html#a0e12e73800927bbae62911d176354832">STREAMLINE_LENGTH</a> = 500</td></tr>
<tr class="separator:a0e12e73800927bbae62911d176354832"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Handles LIC Texture Creation AND Vector Field Reconstruction Methods. </p>
<dl class="section version"><dt>Version</dt><dd>0.1 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2020-01-18</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2020 </dd></dl>

<p class="definition">Definition in file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a525335710b53cb064ca56b936120431e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525335710b53cb064ca56b936120431e">&#9670;&nbsp;</a></span>_USE_MATH_DEFINES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _USE_MATH_DEFINES</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00027">27</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a701214e14bc05250fda7211e5717f361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701214e14bc05250fda7211e5717f361">&#9670;&nbsp;</a></span>bilinear_interpolate_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bilinear_interpolate_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode__main.html">node_main</a> *&#160;</td>
          <td class="paramname"><em>b_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnode__main.html">node_main</a> *&#160;</td>
          <td class="paramname"><em>b_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnode__main.html">node_main</a> *&#160;</td>
          <td class="paramname"><em>t_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnode__main.html">node_main</a> *&#160;</td>
          <td class="paramname"><em>t_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>interpolate the vx and vy values using four nodes. By adding the offset value to node b_left to get the interpolated x and y value and then the resulting interpolated vx and vy is assigned into node b_left.vx_offset and vy_offset the purpose of this function is to use bilinear interpolation to determine the vector value of the offset grid points </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b_left</td><td>bottom left node </td></tr>
    <tr><td class="paramname">b_right</td><td>bottom right node </td></tr>
    <tr><td class="paramname">t_right</td><td>top right node </td></tr>
    <tr><td class="paramname">t_left</td><td>top left node </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00126">126</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a574f648560e17a168c68829af4a8ae54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574f648560e17a168c68829af4a8ae54">&#9670;&nbsp;</a></span>bilinear_interpolate_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float bilinear_interpolate_scalar </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform bilinear interpolation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q11</td><td>bottom left value </td></tr>
    <tr><td class="paramname">q12</td><td>top left value </td></tr>
    <tr><td class="paramname">q21</td><td>bottom right value </td></tr>
    <tr><td class="paramname">q22</td><td>top right value </td></tr>
    <tr><td class="paramname">x1</td><td>left most x </td></tr>
    <tr><td class="paramname">x2</td><td>right most x </td></tr>
    <tr><td class="paramname">y1</td><td>bottom y </td></tr>
    <tr><td class="paramname">y2</td><td>top y </td></tr>
    <tr><td class="paramname">x</td><td>x value of the point to be interpolated </td></tr>
    <tr><td class="paramname">y</td><td>y value of the point to be interpolated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00099">99</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a7c9f43e730b3672285d78352c0fd15d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9f43e730b3672285d78352c0fd15d6">&#9670;&nbsp;</a></span>compute_LIC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_LIC </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enhance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the LIC image </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enhance</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l01120">1120</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a334c2c59d34641767e8b2977d615a996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334c2c59d34641767e8b2977d615a996">&#9670;&nbsp;</a></span>gen_noise_tex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gen_noise_tex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generate the white noise texture for LIC generation </p>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00143">143</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="aaeb2e546816ead289f4c3616d84e4c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb2e546816ead289f4c3616d84e4c38">&#9670;&nbsp;</a></span>get_nearest_streamline_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnode.html">node</a>* get_nearest_streamline_node </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nearest streamline node object, search through all streamlines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x coord of the search </td></tr>
    <tr><td class="paramname">yy</td><td>y coord of the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node* closest streamline node </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00513">513</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a0c4fa02fa864c18cfcdbb258b12dc6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4fa02fa864c18cfcdbb258b12dc6d4">&#9670;&nbsp;</a></span>get_vector_truth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_vector_truth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the values vx and vy of the vector field from the encoded texture array data_img and assign it to vx, vy input </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x value on the data_img texture </td></tr>
    <tr><td class="paramname">yy</td><td>y value on the data_img texture </td></tr>
    <tr><td class="paramname">vx</td><td>the resulting vx value after decoding </td></tr>
    <tr><td class="paramname">vy</td><td>the resulting vy value after decoding </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00040">40</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a7104e8c3b0a2062c3c6685d5bf6ce97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7104e8c3b0a2062c3c6685d5bf6ce97a">&#9670;&nbsp;</a></span>getAbsoluteDiff2Angles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getAbsoluteDiff2Angles </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the absolute diff between two angles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>angle 1 </td></tr>
    <tr><td class="paramname">y</td><td>angle 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double abs difference between two angles </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00053">53</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="ac2ee8e46d8503c2a0549b53e0ff561aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ee8e46d8503c2a0549b53e0ff561aa">&#9670;&nbsp;</a></span>init_grids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_grids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>main function for setting up critical values of the vector field reconstruction process It initializes average error values, the reconstructed vector field values, and begin the vector field construction process </p>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00963">963</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a257bc330e36ebc0af5866cfc0017799b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257bc330e36ebc0af5866cfc0017799b">&#9670;&nbsp;</a></span>interpolate_grid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void interpolate_grid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the values of the interpolated grid based on the original grid </p>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l01105">1105</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="ad1281b52ebf50b61510faeec9030a32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1281b52ebf50b61510faeec9030a32d">&#9670;&nbsp;</a></span>interpolate_streamline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int interpolate_streamline </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reconstruct the vector value of the point (xx,yy) on the vector field by using the Adaptive Weighed Sum method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x coord of the point on the vector field </td></tr>
    <tr><td class="paramname">yy</td><td>y coord of the point on the vector field </td></tr>
    <tr><td class="paramname">vx</td><td>the resulting vx value after reconstruction </td></tr>
    <tr><td class="paramname">vy</td><td>the resulting vy value after reconstruction </td></tr>
    <tr><td class="paramname">radar</td><td>the radar diameter to scan for surrounding streamline nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int how many streamline nodes where found within the radar range, used for recursion. If the result is too few then increase radar range and vice versa </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00301">301</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="aaa8315a9072863e2a64b9f77b1036d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8315a9072863e2a64b9f77b1036d54">&#9670;&nbsp;</a></span>interpolate_streamline_adv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void interpolate_streamline_adv </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: figure out what this method does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td></td></tr>
    <tr><td class="paramname">yy</td><td></td></tr>
    <tr><td class="paramname">vx</td><td></td></tr>
    <tr><td class="paramname">vy</td><td></td></tr>
    <tr><td class="paramname">radar</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00355">355</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="af11e7e720b8967b5e5e3d65a07bb4ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11e7e720b8967b5e5e3d65a07bb4ee8">&#9670;&nbsp;</a></span>interpolate_streamline_raycast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int interpolate_streamline_raycast </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>poor man's raycast implementation, only check four offset points from the desired vector field point. Not very effective </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x coord of the point on the vector field </td></tr>
    <tr><td class="paramname">yy</td><td>y coord of the point on the vector field </td></tr>
    <tr><td class="paramname">vx</td><td>the resulting vx value after reconstruction </td></tr>
    <tr><td class="paramname">vy</td><td>the resulting vy value after reconstruction </td></tr>
    <tr><td class="paramname">radar</td><td>the radar diameter to scan for surrounding streamline nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int how many streamline nodes where found within the radar range, used for recursion. If the result is too few then increase radar range and vice versa </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00542">542</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a7edd5969d04f7427730ca11229696d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edd5969d04f7427730ca11229696d49">&#9670;&nbsp;</a></span>interpolate_streamline_selective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int interpolate_streamline_selective </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reconstruct the vector value of the point (xx,yy) on the vector field by using the Selective Weighed Sum method, this method provides the most reliable reconstruction it first uses the nearest streamline node's vector value as the base, then it finds the next closest node and compare the vector value, if the difference is below the average threshold then it computes the weighted sum between two nodes, if the diff is too large then it discard the second node. The process is repeated untill all nodes within radar range is processed </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x coord of the point on the vector field </td></tr>
    <tr><td class="paramname">yy</td><td>y coord of the point on the vector field </td></tr>
    <tr><td class="paramname">vx</td><td>the resulting vx value after reconstruction </td></tr>
    <tr><td class="paramname">vy</td><td>the resulting vy value after reconstruction </td></tr>
    <tr><td class="paramname">radar</td><td>the radar diameter to scan for surrounding streamline nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int how many streamline nodes where found within the radar range, used for recursion. If the result is too few then increase radar range and vice versa </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00222">222</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a13988a42b45be1a5cb4160c82965f26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13988a42b45be1a5cb4160c82965f26f">&#9670;&nbsp;</a></span>interpolate_streamline_simple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int interpolate_streamline_simple </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reconstruct the vector value of a point by doing a simple weighted sum of all nearby streamline points. This is the least accurate method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x coord of the point on the vector field </td></tr>
    <tr><td class="paramname">yy</td><td>y coord of the point on the vector field </td></tr>
    <tr><td class="paramname">vx</td><td>the resulting vx value after reconstruction </td></tr>
    <tr><td class="paramname">vy</td><td>the resulting vy value after reconstruction </td></tr>
    <tr><td class="paramname">radar</td><td>the radar diameter to scan for surrounding streamline nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int how many streamline nodes where found within the radar range, used for recursion. If the result is too few then increase radar range and vice versa </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00471">471</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="acb7213fbb6217a949fb35df63fbd9f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7213fbb6217a949fb35df63fbd9f8c">&#9670;&nbsp;</a></span>lazy_seeding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lazy_seeding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>uniform streamline seeding method that stops tracing the streamline when it gets too cloest to another streamline </p>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l01139">1139</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a230d5b4c351c593b74f50010d1e395e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230d5b4c351c593b74f50010d1e395e4">&#9670;&nbsp;</a></span>min_distance_to_all_steamlines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float min_distance_to_all_steamlines </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the minimum distance between the current point and the nearest point's streamline </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float min dist </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00067">67</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="ac87cae5571d56b451db2f2018d42b677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87cae5571d56b451db2f2018d42b677">&#9670;&nbsp;</a></span>min_distance_to_steamline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float min_distance_to_steamline </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structnode.html">node</a> &gt; *&#160;</td>
          <td class="paramname"><em>streamline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the minimum distance to a specific streamline from a point x,y </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">streamline</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float min distance to streamline </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00168">168</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a21f961c29f18e6578f3272738013ac9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f961c29f18e6578f3272738013ac9f">&#9670;&nbsp;</a></span>min_node_to_steamline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnode.html">node</a>* min_node_to_steamline </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structnode.html">node</a> &gt; *&#160;</td>
          <td class="paramname"><em>streamline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the closest node to a specific streamline from a point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">streamline</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node* the closest node of that streamline </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00188">188</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="aa2300c2a0e0a396711be37f08d412eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2300c2a0e0a396711be37f08d412eef">&#9670;&nbsp;</a></span>render_vec_img()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void render_vec_img </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_polyhedron.html">Polyhedron</a> *&#160;</td>
          <td class="paramname"><em>this_poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>render the vector field onto a texture for scaling to 512x512 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this_poly</td><td>the read vetor field </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00879">879</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="acdfb182730d63b03a08745835c5106d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfb182730d63b03a08745835c5106d4">&#9670;&nbsp;</a></span>trace_streamline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trace_streamline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enhance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>trace the streamlet to produce the LIC texture </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>start tracing from this x </td></tr>
    <tr><td class="paramname">yy</td><td>start tracing from this y </td></tr>
    <tr><td class="paramname">enhance</td><td>use the enhanced LIC texture or not (0 or 1) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00691">691</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a6e812df5b7c609971288722b7bd2ea71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e812df5b7c609971288722b7bd2ea71">&#9670;&nbsp;</a></span>trace_streamline_custom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structnode.html">node</a>&gt;* trace_streamline_custom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_dis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>trace the streamline based on the given point, will stop when it gets too close to another streamline </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>start tracing from this x </td></tr>
    <tr><td class="paramname">yy</td><td>start tracing from this y </td></tr>
    <tr><td class="paramname">min_dis</td><td>the min distance to another streamline to stop </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;node&gt;* the streamline </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00572">572</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="ae7ef4a9db8b17caa2c8b6120134e8091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ef4a9db8b17caa2c8b6120134e8091">&#9670;&nbsp;</a></span>trace_streamline_old()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trace_streamline_old </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obsolete LIC streamline tracing method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td></td></tr>
    <tr><td class="paramname">yy</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00818">818</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a10e0b1ea070ec97ad7b40ac0d6037d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e0b1ea070ec97ad7b40ac0d6037d6c">&#9670;&nbsp;</a></span>angle_diff_counter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int angle_diff_counter = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00344">344</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a0afaee52a9e947535072c3a099af48ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afaee52a9e947535072c3a099af48ff">&#9670;&nbsp;</a></span>avg_angle_diff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float avg_angle_diff = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00343">343</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a0e12e73800927bbae62911d176354832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e12e73800927bbae62911d176354832">&#9670;&nbsp;</a></span>STREAMLINE_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int STREAMLINE_LENGTH = 500</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00562">562</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="ad369ab96ebde4b09102c400562c9ada2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad369ab96ebde4b09102c400562c9ada2">&#9670;&nbsp;</a></span>v_diff_average</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float v_diff_average = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>trackers for average difference in vector values </p>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00208">208</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a48dc64fa95d54b85644d5c92c38f6066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dc64fa95d54b85644d5c92c38f6066">&#9670;&nbsp;</a></span>v_diff_counter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float v_diff_counter = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00208">208</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_2c12105386bcc5c3935feab96f296a41.html">Downloads</a></li><li class="navelem"><a class="el" href="dir_30b755932e657308fc613c5fcb7ded72.html">Skeleton2017 (1) - Copy</a></li><li class="navelem"><a class="el" href="dir_936078018e40e59bfc341e390554ddc4.html">Skeleton2017_new_zip - Copy</a></li><li class="navelem"><a class="el" href="dir_bd24cd8752e9372b5ca8769065492a5c.html">Skeleton2017</a></li><li class="navelem"><a class="el" href="_l_i_c_8cpp.html">LIC.cpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
