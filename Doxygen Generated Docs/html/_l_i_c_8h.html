<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vector Field Reconstruction: C:/Users/Mango/Downloads/Skeleton2017 (1) - Copy/Skeleton2017_new_zip - Copy/Skeleton2017/LIC.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vector Field Reconstruction
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_l_i_c_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LIC.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="_skeleton_8h_source.html">Skeleton.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="structures_8h_source.html">structures.h</a>&quot;</code><br />
</div>
<p><a href="_l_i_c_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acb7213fbb6217a949fb35df63fbd9f8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#acb7213fbb6217a949fb35df63fbd9f8c">lazy_seeding</a> ()</td></tr>
<tr class="memdesc:acb7213fbb6217a949fb35df63fbd9f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">uniform streamline seeding method that stops tracing the streamline when it gets too cloest to another streamline  <a href="_l_i_c_8h.html#acb7213fbb6217a949fb35df63fbd9f8c">More...</a><br /></td></tr>
<tr class="separator:acb7213fbb6217a949fb35df63fbd9f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9f43e730b3672285d78352c0fd15d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#a7c9f43e730b3672285d78352c0fd15d6">compute_LIC</a> (int enhance)</td></tr>
<tr class="memdesc:a7c9f43e730b3672285d78352c0fd15d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the LIC image  <a href="_l_i_c_8h.html#a7c9f43e730b3672285d78352c0fd15d6">More...</a><br /></td></tr>
<tr class="separator:a7c9f43e730b3672285d78352c0fd15d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257bc330e36ebc0af5866cfc0017799b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#a257bc330e36ebc0af5866cfc0017799b">interpolate_grid</a> ()</td></tr>
<tr class="memdesc:a257bc330e36ebc0af5866cfc0017799b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the values of the interpolated grid based on the original grid  <a href="_l_i_c_8h.html#a257bc330e36ebc0af5866cfc0017799b">More...</a><br /></td></tr>
<tr class="separator:a257bc330e36ebc0af5866cfc0017799b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ee8e46d8503c2a0549b53e0ff561aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#ac2ee8e46d8503c2a0549b53e0ff561aa">init_grids</a> ()</td></tr>
<tr class="memdesc:ac2ee8e46d8503c2a0549b53e0ff561aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">main function for setting up critical values of the vector field reconstruction process It initializes average error values, the reconstructed vector field values, and begin the vector field construction process  <a href="_l_i_c_8h.html#ac2ee8e46d8503c2a0549b53e0ff561aa">More...</a><br /></td></tr>
<tr class="separator:ac2ee8e46d8503c2a0549b53e0ff561aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2300c2a0e0a396711be37f08d412eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#aa2300c2a0e0a396711be37f08d412eef">render_vec_img</a> (<a class="el" href="class_polyhedron.html">Polyhedron</a> *this_poly)</td></tr>
<tr class="memdesc:aa2300c2a0e0a396711be37f08d412eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">render the vector field onto a texture for scaling to 512x512  <a href="_l_i_c_8h.html#aa2300c2a0e0a396711be37f08d412eef">More...</a><br /></td></tr>
<tr class="separator:aa2300c2a0e0a396711be37f08d412eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ef4a9db8b17caa2c8b6120134e8091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#ae7ef4a9db8b17caa2c8b6120134e8091">trace_streamline_old</a> (int xx, int yy)</td></tr>
<tr class="memdesc:ae7ef4a9db8b17caa2c8b6120134e8091"><td class="mdescLeft">&#160;</td><td class="mdescRight">obsolete LIC streamline tracing method  <a href="_l_i_c_8h.html#ae7ef4a9db8b17caa2c8b6120134e8091">More...</a><br /></td></tr>
<tr class="separator:ae7ef4a9db8b17caa2c8b6120134e8091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfb182730d63b03a08745835c5106d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#acdfb182730d63b03a08745835c5106d4">trace_streamline</a> (int xx, int yy, int enhance)</td></tr>
<tr class="memdesc:acdfb182730d63b03a08745835c5106d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">trace the streamlet to produce the LIC texture  <a href="_l_i_c_8h.html#acdfb182730d63b03a08745835c5106d4">More...</a><br /></td></tr>
<tr class="separator:acdfb182730d63b03a08745835c5106d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e812df5b7c609971288722b7bd2ea71"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structnode.html">node</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#a6e812df5b7c609971288722b7bd2ea71">trace_streamline_custom</a> (int xx, int yy, float min_dis)</td></tr>
<tr class="memdesc:a6e812df5b7c609971288722b7bd2ea71"><td class="mdescLeft">&#160;</td><td class="mdescRight">trace the streamline based on the given point, will stop when it gets too close to another streamline  <a href="_l_i_c_8h.html#a6e812df5b7c609971288722b7bd2ea71">More...</a><br /></td></tr>
<tr class="separator:a6e812df5b7c609971288722b7bd2ea71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11e7e720b8967b5e5e3d65a07bb4ee8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#af11e7e720b8967b5e5e3d65a07bb4ee8">interpolate_streamline_raycast</a> (float xx, float yy, float &amp;vx, float &amp;vy, float radar)</td></tr>
<tr class="memdesc:af11e7e720b8967b5e5e3d65a07bb4ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">poor man's raycast implementation, only check four offset points from the desired vector field point. Not very effective  <a href="_l_i_c_8h.html#af11e7e720b8967b5e5e3d65a07bb4ee8">More...</a><br /></td></tr>
<tr class="separator:af11e7e720b8967b5e5e3d65a07bb4ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb2e546816ead289f4c3616d84e4c38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#aaeb2e546816ead289f4c3616d84e4c38">get_nearest_streamline_node</a> (float xx, float yy)</td></tr>
<tr class="memdesc:aaeb2e546816ead289f4c3616d84e4c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nearest streamline node object, search through all streamlines.  <a href="_l_i_c_8h.html#aaeb2e546816ead289f4c3616d84e4c38">More...</a><br /></td></tr>
<tr class="separator:aaeb2e546816ead289f4c3616d84e4c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13988a42b45be1a5cb4160c82965f26f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#a13988a42b45be1a5cb4160c82965f26f">interpolate_streamline_simple</a> (float xx, float yy, float &amp;vx, float &amp;vy, float radar)</td></tr>
<tr class="memdesc:a13988a42b45be1a5cb4160c82965f26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">reconstruct the vector value of a point by doing a simple weighted sum of all nearby streamline points. This is the least accurate method  <a href="_l_i_c_8h.html#a13988a42b45be1a5cb4160c82965f26f">More...</a><br /></td></tr>
<tr class="separator:a13988a42b45be1a5cb4160c82965f26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8315a9072863e2a64b9f77b1036d54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#aaa8315a9072863e2a64b9f77b1036d54">interpolate_streamline_adv</a> (float xx, float yy, float &amp;vx, float &amp;vy, float radar)</td></tr>
<tr class="memdesc:aaa8315a9072863e2a64b9f77b1036d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: figure out what this method does.  <a href="_l_i_c_8h.html#aaa8315a9072863e2a64b9f77b1036d54">More...</a><br /></td></tr>
<tr class="separator:aaa8315a9072863e2a64b9f77b1036d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1281b52ebf50b61510faeec9030a32d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#ad1281b52ebf50b61510faeec9030a32d">interpolate_streamline</a> (float xx, float yy, float &amp;vx, float &amp;vy, float radar)</td></tr>
<tr class="memdesc:ad1281b52ebf50b61510faeec9030a32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">reconstruct the vector value of the point (xx,yy) on the vector field by using the Adaptive Weighed Sum method  <a href="_l_i_c_8h.html#ad1281b52ebf50b61510faeec9030a32d">More...</a><br /></td></tr>
<tr class="separator:ad1281b52ebf50b61510faeec9030a32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edd5969d04f7427730ca11229696d49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#a7edd5969d04f7427730ca11229696d49">interpolate_streamline_selective</a> (float xx, float yy, float &amp;vx, float &amp;vy, float radar)</td></tr>
<tr class="memdesc:a7edd5969d04f7427730ca11229696d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">reconstruct the vector value of the point (xx,yy) on the vector field by using the Selective Weighed Sum method, this method provides the most reliable reconstruction it first uses the nearest streamline node's vector value as the base, then it finds the next closest node and compare the vector value, if the difference is below the average threshold then it computes the weighted sum between two nodes, if the diff is too large then it discard the second node. The process is repeated untill all nodes within radar range is processed  <a href="_l_i_c_8h.html#a7edd5969d04f7427730ca11229696d49">More...</a><br /></td></tr>
<tr class="separator:a7edd5969d04f7427730ca11229696d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f961c29f18e6578f3272738013ac9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#a21f961c29f18e6578f3272738013ac9f">min_node_to_steamline</a> (float x, float y, std::vector&lt; <a class="el" href="structnode.html">node</a> &gt; *streamline)</td></tr>
<tr class="memdesc:a21f961c29f18e6578f3272738013ac9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the closest node to a specific streamline from a point  <a href="_l_i_c_8h.html#a21f961c29f18e6578f3272738013ac9f">More...</a><br /></td></tr>
<tr class="separator:a21f961c29f18e6578f3272738013ac9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87cae5571d56b451db2f2018d42b677"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#ac87cae5571d56b451db2f2018d42b677">min_distance_to_steamline</a> (float x, float y, std::vector&lt; <a class="el" href="structnode.html">node</a> &gt; *streamline)</td></tr>
<tr class="memdesc:ac87cae5571d56b451db2f2018d42b677"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the minimum distance to a specific streamline from a point x,y  <a href="_l_i_c_8h.html#ac87cae5571d56b451db2f2018d42b677">More...</a><br /></td></tr>
<tr class="separator:ac87cae5571d56b451db2f2018d42b677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334c2c59d34641767e8b2977d615a996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#a334c2c59d34641767e8b2977d615a996">gen_noise_tex</a> ()</td></tr>
<tr class="memdesc:a334c2c59d34641767e8b2977d615a996"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate the white noise texture for LIC generation  <a href="_l_i_c_8h.html#a334c2c59d34641767e8b2977d615a996">More...</a><br /></td></tr>
<tr class="separator:a334c2c59d34641767e8b2977d615a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701214e14bc05250fda7211e5717f361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#a701214e14bc05250fda7211e5717f361">bilinear_interpolate_node</a> (<a class="el" href="structnode__main.html">node_main</a> *b_left, <a class="el" href="structnode__main.html">node_main</a> *b_right, <a class="el" href="structnode__main.html">node_main</a> *t_right, <a class="el" href="structnode__main.html">node_main</a> *t_left)</td></tr>
<tr class="memdesc:a701214e14bc05250fda7211e5717f361"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpolate the vx and vy values using four nodes. By adding the offset value to node b_left to get the interpolated x and y value and then the resulting interpolated vx and vy is assigned into node b_left.vx_offset and vy_offset the purpose of this function is to use bilinear interpolation to determine the vector value of the offset grid points  <a href="_l_i_c_8h.html#a701214e14bc05250fda7211e5717f361">More...</a><br /></td></tr>
<tr class="separator:a701214e14bc05250fda7211e5717f361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574f648560e17a168c68829af4a8ae54"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#a574f648560e17a168c68829af4a8ae54">bilinear_interpolate_scalar</a> (float q11, float q12, float q21, float q22, float x1, float x2, float y1, float y2, float x, float y)</td></tr>
<tr class="memdesc:a574f648560e17a168c68829af4a8ae54"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform bilinear interpolation  <a href="_l_i_c_8h.html#a574f648560e17a168c68829af4a8ae54">More...</a><br /></td></tr>
<tr class="separator:a574f648560e17a168c68829af4a8ae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230d5b4c351c593b74f50010d1e395e4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#a230d5b4c351c593b74f50010d1e395e4">min_distance_to_all_steamlines</a> (float x, float y)</td></tr>
<tr class="memdesc:a230d5b4c351c593b74f50010d1e395e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the minimum distance between the current point and the nearest point's streamline  <a href="_l_i_c_8h.html#a230d5b4c351c593b74f50010d1e395e4">More...</a><br /></td></tr>
<tr class="separator:a230d5b4c351c593b74f50010d1e395e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7104e8c3b0a2062c3c6685d5bf6ce97a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#a7104e8c3b0a2062c3c6685d5bf6ce97a">getAbsoluteDiff2Angles</a> (const double x, const double y)</td></tr>
<tr class="memdesc:a7104e8c3b0a2062c3c6685d5bf6ce97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute diff between two angles.  <a href="_l_i_c_8h.html#a7104e8c3b0a2062c3c6685d5bf6ce97a">More...</a><br /></td></tr>
<tr class="separator:a7104e8c3b0a2062c3c6685d5bf6ce97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4fa02fa864c18cfcdbb258b12dc6d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l_i_c_8h.html#a0c4fa02fa864c18cfcdbb258b12dc6d4">get_vector_truth</a> (int xx, int yy, float &amp;vx, float &amp;vy)</td></tr>
<tr class="memdesc:a0c4fa02fa864c18cfcdbb258b12dc6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the values vx and vy of the vector field from the encoded texture array data_img and assign it to vx, vy input  <a href="_l_i_c_8h.html#a0c4fa02fa864c18cfcdbb258b12dc6d4">More...</a><br /></td></tr>
<tr class="separator:a0c4fa02fa864c18cfcdbb258b12dc6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a701214e14bc05250fda7211e5717f361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701214e14bc05250fda7211e5717f361">&#9670;&nbsp;</a></span>bilinear_interpolate_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bilinear_interpolate_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode__main.html">node_main</a> *&#160;</td>
          <td class="paramname"><em>b_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnode__main.html">node_main</a> *&#160;</td>
          <td class="paramname"><em>b_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnode__main.html">node_main</a> *&#160;</td>
          <td class="paramname"><em>t_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnode__main.html">node_main</a> *&#160;</td>
          <td class="paramname"><em>t_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>interpolate the vx and vy values using four nodes. By adding the offset value to node b_left to get the interpolated x and y value and then the resulting interpolated vx and vy is assigned into node b_left.vx_offset and vy_offset the purpose of this function is to use bilinear interpolation to determine the vector value of the offset grid points </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b_left</td><td>bottom left node </td></tr>
    <tr><td class="paramname">b_right</td><td>bottom right node </td></tr>
    <tr><td class="paramname">t_right</td><td>top right node </td></tr>
    <tr><td class="paramname">t_left</td><td>top left node </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00126">126</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a574f648560e17a168c68829af4a8ae54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574f648560e17a168c68829af4a8ae54">&#9670;&nbsp;</a></span>bilinear_interpolate_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float bilinear_interpolate_scalar </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform bilinear interpolation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q11</td><td>bottom left value </td></tr>
    <tr><td class="paramname">q12</td><td>top left value </td></tr>
    <tr><td class="paramname">q21</td><td>bottom right value </td></tr>
    <tr><td class="paramname">q22</td><td>top right value </td></tr>
    <tr><td class="paramname">x1</td><td>left most x </td></tr>
    <tr><td class="paramname">x2</td><td>right most x </td></tr>
    <tr><td class="paramname">y1</td><td>bottom y </td></tr>
    <tr><td class="paramname">y2</td><td>top y </td></tr>
    <tr><td class="paramname">x</td><td>x value of the point to be interpolated </td></tr>
    <tr><td class="paramname">y</td><td>y value of the point to be interpolated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00099">99</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a7c9f43e730b3672285d78352c0fd15d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9f43e730b3672285d78352c0fd15d6">&#9670;&nbsp;</a></span>compute_LIC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_LIC </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enhance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the LIC image </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enhance</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l01120">1120</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a334c2c59d34641767e8b2977d615a996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334c2c59d34641767e8b2977d615a996">&#9670;&nbsp;</a></span>gen_noise_tex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gen_noise_tex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generate the white noise texture for LIC generation </p>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00143">143</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="aaeb2e546816ead289f4c3616d84e4c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb2e546816ead289f4c3616d84e4c38">&#9670;&nbsp;</a></span>get_nearest_streamline_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnode.html">node</a>* get_nearest_streamline_node </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nearest streamline node object, search through all streamlines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x coord of the search </td></tr>
    <tr><td class="paramname">yy</td><td>y coord of the search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node* closest streamline node </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00513">513</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a0c4fa02fa864c18cfcdbb258b12dc6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4fa02fa864c18cfcdbb258b12dc6d4">&#9670;&nbsp;</a></span>get_vector_truth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_vector_truth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the values vx and vy of the vector field from the encoded texture array data_img and assign it to vx, vy input </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x value on the data_img texture </td></tr>
    <tr><td class="paramname">yy</td><td>y value on the data_img texture </td></tr>
    <tr><td class="paramname">vx</td><td>the resulting vx value after decoding </td></tr>
    <tr><td class="paramname">vy</td><td>the resulting vy value after decoding </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00040">40</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a7104e8c3b0a2062c3c6685d5bf6ce97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7104e8c3b0a2062c3c6685d5bf6ce97a">&#9670;&nbsp;</a></span>getAbsoluteDiff2Angles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getAbsoluteDiff2Angles </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the absolute diff between two angles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>angle 1 </td></tr>
    <tr><td class="paramname">y</td><td>angle 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double abs difference between two angles </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00053">53</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="ac2ee8e46d8503c2a0549b53e0ff561aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ee8e46d8503c2a0549b53e0ff561aa">&#9670;&nbsp;</a></span>init_grids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_grids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>main function for setting up critical values of the vector field reconstruction process It initializes average error values, the reconstructed vector field values, and begin the vector field construction process </p>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00963">963</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a257bc330e36ebc0af5866cfc0017799b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257bc330e36ebc0af5866cfc0017799b">&#9670;&nbsp;</a></span>interpolate_grid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void interpolate_grid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the values of the interpolated grid based on the original grid </p>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l01105">1105</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="ad1281b52ebf50b61510faeec9030a32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1281b52ebf50b61510faeec9030a32d">&#9670;&nbsp;</a></span>interpolate_streamline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int interpolate_streamline </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reconstruct the vector value of the point (xx,yy) on the vector field by using the Adaptive Weighed Sum method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x coord of the point on the vector field </td></tr>
    <tr><td class="paramname">yy</td><td>y coord of the point on the vector field </td></tr>
    <tr><td class="paramname">vx</td><td>the resulting vx value after reconstruction </td></tr>
    <tr><td class="paramname">vy</td><td>the resulting vy value after reconstruction </td></tr>
    <tr><td class="paramname">radar</td><td>the radar diameter to scan for surrounding streamline nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int how many streamline nodes where found within the radar range, used for recursion. If the result is too few then increase radar range and vice versa </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00301">301</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="aaa8315a9072863e2a64b9f77b1036d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8315a9072863e2a64b9f77b1036d54">&#9670;&nbsp;</a></span>interpolate_streamline_adv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void interpolate_streamline_adv </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: figure out what this method does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td></td></tr>
    <tr><td class="paramname">yy</td><td></td></tr>
    <tr><td class="paramname">vx</td><td></td></tr>
    <tr><td class="paramname">vy</td><td></td></tr>
    <tr><td class="paramname">radar</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00355">355</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="af11e7e720b8967b5e5e3d65a07bb4ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11e7e720b8967b5e5e3d65a07bb4ee8">&#9670;&nbsp;</a></span>interpolate_streamline_raycast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int interpolate_streamline_raycast </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>poor man's raycast implementation, only check four offset points from the desired vector field point. Not very effective </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x coord of the point on the vector field </td></tr>
    <tr><td class="paramname">yy</td><td>y coord of the point on the vector field </td></tr>
    <tr><td class="paramname">vx</td><td>the resulting vx value after reconstruction </td></tr>
    <tr><td class="paramname">vy</td><td>the resulting vy value after reconstruction </td></tr>
    <tr><td class="paramname">radar</td><td>the radar diameter to scan for surrounding streamline nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int how many streamline nodes where found within the radar range, used for recursion. If the result is too few then increase radar range and vice versa </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00542">542</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a7edd5969d04f7427730ca11229696d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edd5969d04f7427730ca11229696d49">&#9670;&nbsp;</a></span>interpolate_streamline_selective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int interpolate_streamline_selective </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reconstruct the vector value of the point (xx,yy) on the vector field by using the Selective Weighed Sum method, this method provides the most reliable reconstruction it first uses the nearest streamline node's vector value as the base, then it finds the next closest node and compare the vector value, if the difference is below the average threshold then it computes the weighted sum between two nodes, if the diff is too large then it discard the second node. The process is repeated untill all nodes within radar range is processed </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x coord of the point on the vector field </td></tr>
    <tr><td class="paramname">yy</td><td>y coord of the point on the vector field </td></tr>
    <tr><td class="paramname">vx</td><td>the resulting vx value after reconstruction </td></tr>
    <tr><td class="paramname">vy</td><td>the resulting vy value after reconstruction </td></tr>
    <tr><td class="paramname">radar</td><td>the radar diameter to scan for surrounding streamline nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int how many streamline nodes where found within the radar range, used for recursion. If the result is too few then increase radar range and vice versa </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00222">222</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a13988a42b45be1a5cb4160c82965f26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13988a42b45be1a5cb4160c82965f26f">&#9670;&nbsp;</a></span>interpolate_streamline_simple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int interpolate_streamline_simple </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>vy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reconstruct the vector value of a point by doing a simple weighted sum of all nearby streamline points. This is the least accurate method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>x coord of the point on the vector field </td></tr>
    <tr><td class="paramname">yy</td><td>y coord of the point on the vector field </td></tr>
    <tr><td class="paramname">vx</td><td>the resulting vx value after reconstruction </td></tr>
    <tr><td class="paramname">vy</td><td>the resulting vy value after reconstruction </td></tr>
    <tr><td class="paramname">radar</td><td>the radar diameter to scan for surrounding streamline nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int how many streamline nodes where found within the radar range, used for recursion. If the result is too few then increase radar range and vice versa </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00471">471</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="acb7213fbb6217a949fb35df63fbd9f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7213fbb6217a949fb35df63fbd9f8c">&#9670;&nbsp;</a></span>lazy_seeding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lazy_seeding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>uniform streamline seeding method that stops tracing the streamline when it gets too cloest to another streamline </p>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l01139">1139</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a230d5b4c351c593b74f50010d1e395e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230d5b4c351c593b74f50010d1e395e4">&#9670;&nbsp;</a></span>min_distance_to_all_steamlines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float min_distance_to_all_steamlines </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the minimum distance between the current point and the nearest point's streamline </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float min dist </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00067">67</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="ac87cae5571d56b451db2f2018d42b677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87cae5571d56b451db2f2018d42b677">&#9670;&nbsp;</a></span>min_distance_to_steamline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float min_distance_to_steamline </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structnode.html">node</a> &gt; *&#160;</td>
          <td class="paramname"><em>streamline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the minimum distance to a specific streamline from a point x,y </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">streamline</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float min distance to streamline </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00168">168</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a21f961c29f18e6578f3272738013ac9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f961c29f18e6578f3272738013ac9f">&#9670;&nbsp;</a></span>min_node_to_steamline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnode.html">node</a>* min_node_to_steamline </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structnode.html">node</a> &gt; *&#160;</td>
          <td class="paramname"><em>streamline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the closest node to a specific streamline from a point </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">streamline</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node* the closest node of that streamline </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00188">188</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="aa2300c2a0e0a396711be37f08d412eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2300c2a0e0a396711be37f08d412eef">&#9670;&nbsp;</a></span>render_vec_img()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void render_vec_img </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_polyhedron.html">Polyhedron</a> *&#160;</td>
          <td class="paramname"><em>this_poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>render the vector field onto a texture for scaling to 512x512 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this_poly</td><td>the read vetor field </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00879">879</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="acdfb182730d63b03a08745835c5106d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfb182730d63b03a08745835c5106d4">&#9670;&nbsp;</a></span>trace_streamline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trace_streamline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enhance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>trace the streamlet to produce the LIC texture </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>start tracing from this x </td></tr>
    <tr><td class="paramname">yy</td><td>start tracing from this y </td></tr>
    <tr><td class="paramname">enhance</td><td>use the enhanced LIC texture or not (0 or 1) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00691">691</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="a6e812df5b7c609971288722b7bd2ea71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e812df5b7c609971288722b7bd2ea71">&#9670;&nbsp;</a></span>trace_streamline_custom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structnode.html">node</a>&gt;* trace_streamline_custom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_dis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>trace the streamline based on the given point, will stop when it gets too close to another streamline </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td>start tracing from this x </td></tr>
    <tr><td class="paramname">yy</td><td>start tracing from this y </td></tr>
    <tr><td class="paramname">min_dis</td><td>the min distance to another streamline to stop </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;node&gt;* the streamline </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00572">572</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
<a id="ae7ef4a9db8b17caa2c8b6120134e8091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ef4a9db8b17caa2c8b6120134e8091">&#9670;&nbsp;</a></span>trace_streamline_old()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trace_streamline_old </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obsolete LIC streamline tracing method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xx</td><td></td></tr>
    <tr><td class="paramname">yy</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_i_c_8cpp_source.html#l00818">818</a> of file <a class="el" href="_l_i_c_8cpp_source.html">LIC.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_2c12105386bcc5c3935feab96f296a41.html">Downloads</a></li><li class="navelem"><a class="el" href="dir_30b755932e657308fc613c5fcb7ded72.html">Skeleton2017 (1) - Copy</a></li><li class="navelem"><a class="el" href="dir_936078018e40e59bfc341e390554ddc4.html">Skeleton2017_new_zip - Copy</a></li><li class="navelem"><a class="el" href="dir_bd24cd8752e9372b5ca8769065492a5c.html">Skeleton2017</a></li><li class="navelem"><a class="el" href="_l_i_c_8h.html">LIC.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
