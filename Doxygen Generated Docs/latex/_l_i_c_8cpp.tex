\hypertarget{_l_i_c_8cpp}{}\doxysection{C\+:/\+Users/\+Mango/\+Downloads/\+Skeleton2017 (1) -\/ Copy/\+Skeleton2017\+\_\+new\+\_\+zip -\/ Copy/\+Skeleton2017/\+L\+IC.cpp File Reference}
\label{_l_i_c_8cpp}\index{C:/Users/Mango/Downloads/Skeleton2017 (1) -\/ Copy/Skeleton2017\_new\_zip -\/ Copy/Skeleton2017/LIC.cpp@{C:/Users/Mango/Downloads/Skeleton2017 (1) -\/ Copy/Skeleton2017\_new\_zip -\/ Copy/Skeleton2017/LIC.cpp}}


Handles L\+IC Texture Creation A\+ND Vector Field Reconstruction Methods.  


{\ttfamily \#include $<$windows.\+h$>$}\newline
{\ttfamily \#include \char`\"{}G\+L\textbackslash{}include\textbackslash{}\+G\+L.\+H\char`\"{}}\newline
{\ttfamily \#include \char`\"{}G\+L\textbackslash{}include\textbackslash{}glu.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}G\+L\textbackslash{}include\textbackslash{}glut.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}G\+L\textbackslash{}include\textbackslash{}glui.\+h\char`\"{}}\newline
{\ttfamily \#include $<$ctype.\+h$>$}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$sstream$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$fstream$>$}\newline
{\ttfamily \#include \char`\"{}Reader.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}structures.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}globals.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}Skeleton.\+h\char`\"{}}\newline
{\ttfamily \#include $<$math.\+h$>$}\newline
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{_l_i_c_8cpp_a525335710b53cb064ca56b936120431e}{\+\_\+\+U\+S\+E\+\_\+\+M\+A\+T\+H\+\_\+\+D\+E\+F\+I\+N\+ES}}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{_l_i_c_8cpp_acb7213fbb6217a949fb35df63fbd9f8c}{lazy\+\_\+seeding}} ()
\begin{DoxyCompactList}\small\item\em uniform streamline seeding method that stops tracing the streamline when it gets too cloest to another streamline \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_l_i_c_8cpp_a0c4fa02fa864c18cfcdbb258b12dc6d4}{get\+\_\+vector\+\_\+truth}} (int xx, int yy, float \&vx, float \&vy)
\begin{DoxyCompactList}\small\item\em set the values vx and vy of the vector field from the encoded texture array data\+\_\+img and assign it to vx, vy input \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_l_i_c_8cpp_a7104e8c3b0a2062c3c6685d5bf6ce97a}{get\+Absolute\+Diff2\+Angles}} (const double x, const double y)
\begin{DoxyCompactList}\small\item\em Get the absolute diff between two angles. \end{DoxyCompactList}\item 
float \mbox{\hyperlink{_l_i_c_8cpp_a230d5b4c351c593b74f50010d1e395e4}{min\+\_\+distance\+\_\+to\+\_\+all\+\_\+steamlines}} (float x, float y)
\begin{DoxyCompactList}\small\item\em get the minimum distance between the current point and the nearest point\textquotesingle{}s streamline \end{DoxyCompactList}\item 
float \mbox{\hyperlink{_l_i_c_8cpp_a574f648560e17a168c68829af4a8ae54}{bilinear\+\_\+interpolate\+\_\+scalar}} (float q11, float q12, float q21, float q22, float x1, float x2, float y1, float y2, float x, float y)
\begin{DoxyCompactList}\small\item\em perform bilinear interpolation \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_l_i_c_8cpp_a701214e14bc05250fda7211e5717f361}{bilinear\+\_\+interpolate\+\_\+node}} (\mbox{\hyperlink{structnode__main}{node\+\_\+main}} $\ast$b\+\_\+left, \mbox{\hyperlink{structnode__main}{node\+\_\+main}} $\ast$b\+\_\+right, \mbox{\hyperlink{structnode__main}{node\+\_\+main}} $\ast$t\+\_\+right, \mbox{\hyperlink{structnode__main}{node\+\_\+main}} $\ast$t\+\_\+left)
\begin{DoxyCompactList}\small\item\em interpolate the vx and vy values using four nodes. By adding the offset value to node b\+\_\+left to get the interpolated x and y value and then the resulting interpolated vx and vy is assigned into node b\+\_\+left.\+vx\+\_\+offset and vy\+\_\+offset the purpose of this function is to use bilinear interpolation to determine the vector value of the offset grid points \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_l_i_c_8cpp_a334c2c59d34641767e8b2977d615a996}{gen\+\_\+noise\+\_\+tex}} ()
\begin{DoxyCompactList}\small\item\em generate the white noise texture for L\+IC generation \end{DoxyCompactList}\item 
float \mbox{\hyperlink{_l_i_c_8cpp_ac87cae5571d56b451db2f2018d42b677}{min\+\_\+distance\+\_\+to\+\_\+steamline}} (float x, float y, std\+::vector$<$ \mbox{\hyperlink{structnode}{node}} $>$ $\ast$streamline)
\begin{DoxyCompactList}\small\item\em get the minimum distance to a specific streamline from a point x,y \end{DoxyCompactList}\item 
\mbox{\hyperlink{structnode}{node}} $\ast$ \mbox{\hyperlink{_l_i_c_8cpp_a21f961c29f18e6578f3272738013ac9f}{min\+\_\+node\+\_\+to\+\_\+steamline}} (float x, float y, std\+::vector$<$ \mbox{\hyperlink{structnode}{node}} $>$ $\ast$streamline)
\begin{DoxyCompactList}\small\item\em get the closest node to a specific streamline from a point \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_l_i_c_8cpp_a7edd5969d04f7427730ca11229696d49}{interpolate\+\_\+streamline\+\_\+selective}} (float xx, float yy, float \&vx, float \&vy, float radar)
\begin{DoxyCompactList}\small\item\em reconstruct the vector value of the point (xx,yy) on the vector field by using the Selective Weighed Sum method, this method provides the most reliable reconstruction it first uses the nearest streamline node\textquotesingle{}s vector value as the base, then it finds the next closest node and compare the vector value, if the difference is below the average threshold then it computes the weighted sum between two nodes, if the diff is too large then it discard the second node. The process is repeated untill all nodes within radar range is processed \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_l_i_c_8cpp_ad1281b52ebf50b61510faeec9030a32d}{interpolate\+\_\+streamline}} (float xx, float yy, float \&vx, float \&vy, float radar)
\begin{DoxyCompactList}\small\item\em reconstruct the vector value of the point (xx,yy) on the vector field by using the Adaptive Weighed Sum method \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_l_i_c_8cpp_aaa8315a9072863e2a64b9f77b1036d54}{interpolate\+\_\+streamline\+\_\+adv}} (float xx, float yy, float \&vx, float \&vy, float radar)
\begin{DoxyCompactList}\small\item\em T\+O\+DO\+: figure out what this method does. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_l_i_c_8cpp_a13988a42b45be1a5cb4160c82965f26f}{interpolate\+\_\+streamline\+\_\+simple}} (float xx, float yy, float \&vx, float \&vy, float radar)
\begin{DoxyCompactList}\small\item\em reconstruct the vector value of a point by doing a simple weighted sum of all nearby streamline points. This is the least accurate method \end{DoxyCompactList}\item 
\mbox{\hyperlink{structnode}{node}} $\ast$ \mbox{\hyperlink{_l_i_c_8cpp_aaeb2e546816ead289f4c3616d84e4c38}{get\+\_\+nearest\+\_\+streamline\+\_\+node}} (float xx, float yy)
\begin{DoxyCompactList}\small\item\em Get the nearest streamline node object, search through all streamlines. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_l_i_c_8cpp_af11e7e720b8967b5e5e3d65a07bb4ee8}{interpolate\+\_\+streamline\+\_\+raycast}} (float xx, float yy, float \&vx, float \&vy, float radar)
\begin{DoxyCompactList}\small\item\em poor man\textquotesingle{}s raycast implementation, only check four offset points from the desired vector field point. Not very effective \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{structnode}{node}} $>$ $\ast$ \mbox{\hyperlink{_l_i_c_8cpp_a6e812df5b7c609971288722b7bd2ea71}{trace\+\_\+streamline\+\_\+custom}} (int xx, int yy, float min\+\_\+dis)
\begin{DoxyCompactList}\small\item\em trace the streamline based on the given point, will stop when it gets too close to another streamline \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_l_i_c_8cpp_acdfb182730d63b03a08745835c5106d4}{trace\+\_\+streamline}} (int xx, int yy, int enhance)
\begin{DoxyCompactList}\small\item\em trace the streamlet to produce the L\+IC texture \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_l_i_c_8cpp_ac2ee8e46d8503c2a0549b53e0ff561aa}{init\+\_\+grids}} ()
\begin{DoxyCompactList}\small\item\em main function for setting up critical values of the vector field reconstruction process It initializes average error values, the reconstructed vector field values, and begin the vector field construction process \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_l_i_c_8cpp_ae7ef4a9db8b17caa2c8b6120134e8091}{trace\+\_\+streamline\+\_\+old}} (int xx, int yy)
\begin{DoxyCompactList}\small\item\em obsolete L\+IC streamline tracing method \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_l_i_c_8cpp_aa2300c2a0e0a396711be37f08d412eef}{render\+\_\+vec\+\_\+img}} (\mbox{\hyperlink{class_polyhedron}{Polyhedron}} $\ast$this\+\_\+poly)
\begin{DoxyCompactList}\small\item\em render the vector field onto a texture for scaling to 512x512 \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_l_i_c_8cpp_a257bc330e36ebc0af5866cfc0017799b}{interpolate\+\_\+grid}} ()
\begin{DoxyCompactList}\small\item\em set the values of the interpolated grid based on the original grid \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_l_i_c_8cpp_a7c9f43e730b3672285d78352c0fd15d6}{compute\+\_\+\+L\+IC}} (int enhance)
\begin{DoxyCompactList}\small\item\em compute the L\+IC image \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
float \mbox{\hyperlink{_l_i_c_8cpp_ad369ab96ebde4b09102c400562c9ada2}{v\+\_\+diff\+\_\+average}} = 0
\begin{DoxyCompactList}\small\item\em trackers for average difference in vector values \end{DoxyCompactList}\item 
float \mbox{\hyperlink{_l_i_c_8cpp_a48dc64fa95d54b85644d5c92c38f6066}{v\+\_\+diff\+\_\+counter}} = 0
\item 
float \mbox{\hyperlink{_l_i_c_8cpp_a0afaee52a9e947535072c3a099af48ff}{avg\+\_\+angle\+\_\+diff}} = 0
\item 
int \mbox{\hyperlink{_l_i_c_8cpp_a10e0b1ea070ec97ad7b40ac0d6037d6c}{angle\+\_\+diff\+\_\+counter}} = 0
\item 
int \mbox{\hyperlink{_l_i_c_8cpp_a0e12e73800927bbae62911d176354832}{S\+T\+R\+E\+A\+M\+L\+I\+N\+E\+\_\+\+L\+E\+N\+G\+TH}} = 500
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Handles L\+IC Texture Creation A\+ND Vector Field Reconstruction Methods. 

\begin{DoxyVersion}{Version}
0.\+1 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
2020-\/01-\/18
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
Copyright (c) 2020 
\end{DoxyCopyright}


\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{_l_i_c_8cpp_a525335710b53cb064ca56b936120431e}\label{_l_i_c_8cpp_a525335710b53cb064ca56b936120431e}} 
\index{LIC.cpp@{LIC.cpp}!\_USE\_MATH\_DEFINES@{\_USE\_MATH\_DEFINES}}
\index{\_USE\_MATH\_DEFINES@{\_USE\_MATH\_DEFINES}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{\_USE\_MATH\_DEFINES}{\_USE\_MATH\_DEFINES}}
{\footnotesize\ttfamily \#define \+\_\+\+U\+S\+E\+\_\+\+M\+A\+T\+H\+\_\+\+D\+E\+F\+I\+N\+ES}



Definition at line 27 of file L\+I\+C.\+cpp.



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{_l_i_c_8cpp_a701214e14bc05250fda7211e5717f361}\label{_l_i_c_8cpp_a701214e14bc05250fda7211e5717f361}} 
\index{LIC.cpp@{LIC.cpp}!bilinear\_interpolate\_node@{bilinear\_interpolate\_node}}
\index{bilinear\_interpolate\_node@{bilinear\_interpolate\_node}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{bilinear\_interpolate\_node()}{bilinear\_interpolate\_node()}}
{\footnotesize\ttfamily void bilinear\+\_\+interpolate\+\_\+node (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structnode__main}{node\+\_\+main}} $\ast$}]{b\+\_\+left,  }\item[{\mbox{\hyperlink{structnode__main}{node\+\_\+main}} $\ast$}]{b\+\_\+right,  }\item[{\mbox{\hyperlink{structnode__main}{node\+\_\+main}} $\ast$}]{t\+\_\+right,  }\item[{\mbox{\hyperlink{structnode__main}{node\+\_\+main}} $\ast$}]{t\+\_\+left }\end{DoxyParamCaption})}



interpolate the vx and vy values using four nodes. By adding the offset value to node b\+\_\+left to get the interpolated x and y value and then the resulting interpolated vx and vy is assigned into node b\+\_\+left.\+vx\+\_\+offset and vy\+\_\+offset the purpose of this function is to use bilinear interpolation to determine the vector value of the offset grid points 


\begin{DoxyParams}{Parameters}
{\em b\+\_\+left} & bottom left node \\
\hline
{\em b\+\_\+right} & bottom right node \\
\hline
{\em t\+\_\+right} & top right node \\
\hline
{\em t\+\_\+left} & top left node \\
\hline
\end{DoxyParams}


Definition at line 126 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a574f648560e17a168c68829af4a8ae54}\label{_l_i_c_8cpp_a574f648560e17a168c68829af4a8ae54}} 
\index{LIC.cpp@{LIC.cpp}!bilinear\_interpolate\_scalar@{bilinear\_interpolate\_scalar}}
\index{bilinear\_interpolate\_scalar@{bilinear\_interpolate\_scalar}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{bilinear\_interpolate\_scalar()}{bilinear\_interpolate\_scalar()}}
{\footnotesize\ttfamily float bilinear\+\_\+interpolate\+\_\+scalar (\begin{DoxyParamCaption}\item[{float}]{q11,  }\item[{float}]{q12,  }\item[{float}]{q21,  }\item[{float}]{q22,  }\item[{float}]{x1,  }\item[{float}]{x2,  }\item[{float}]{y1,  }\item[{float}]{y2,  }\item[{float}]{x,  }\item[{float}]{y }\end{DoxyParamCaption})}



perform bilinear interpolation 


\begin{DoxyParams}{Parameters}
{\em q11} & bottom left value \\
\hline
{\em q12} & top left value \\
\hline
{\em q21} & bottom right value \\
\hline
{\em q22} & top right value \\
\hline
{\em x1} & left most x \\
\hline
{\em x2} & right most x \\
\hline
{\em y1} & bottom y \\
\hline
{\em y2} & top y \\
\hline
{\em x} & x value of the point to be interpolated \\
\hline
{\em y} & y value of the point to be interpolated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
float 
\end{DoxyReturn}


Definition at line 99 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a7c9f43e730b3672285d78352c0fd15d6}\label{_l_i_c_8cpp_a7c9f43e730b3672285d78352c0fd15d6}} 
\index{LIC.cpp@{LIC.cpp}!compute\_LIC@{compute\_LIC}}
\index{compute\_LIC@{compute\_LIC}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{compute\_LIC()}{compute\_LIC()}}
{\footnotesize\ttfamily void compute\+\_\+\+L\+IC (\begin{DoxyParamCaption}\item[{int}]{enhance }\end{DoxyParamCaption})}



compute the L\+IC image 


\begin{DoxyParams}{Parameters}
{\em enhance} & \\
\hline
\end{DoxyParams}


Definition at line 1120 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a334c2c59d34641767e8b2977d615a996}\label{_l_i_c_8cpp_a334c2c59d34641767e8b2977d615a996}} 
\index{LIC.cpp@{LIC.cpp}!gen\_noise\_tex@{gen\_noise\_tex}}
\index{gen\_noise\_tex@{gen\_noise\_tex}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{gen\_noise\_tex()}{gen\_noise\_tex()}}
{\footnotesize\ttfamily void gen\+\_\+noise\+\_\+tex (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



generate the white noise texture for L\+IC generation 



Definition at line 143 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_aaeb2e546816ead289f4c3616d84e4c38}\label{_l_i_c_8cpp_aaeb2e546816ead289f4c3616d84e4c38}} 
\index{LIC.cpp@{LIC.cpp}!get\_nearest\_streamline\_node@{get\_nearest\_streamline\_node}}
\index{get\_nearest\_streamline\_node@{get\_nearest\_streamline\_node}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{get\_nearest\_streamline\_node()}{get\_nearest\_streamline\_node()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structnode}{node}}$\ast$ get\+\_\+nearest\+\_\+streamline\+\_\+node (\begin{DoxyParamCaption}\item[{float}]{xx,  }\item[{float}]{yy }\end{DoxyParamCaption})}



Get the nearest streamline node object, search through all streamlines. 


\begin{DoxyParams}{Parameters}
{\em xx} & x coord of the search \\
\hline
{\em yy} & y coord of the search \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
node$\ast$ closest streamline node 
\end{DoxyReturn}


Definition at line 513 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a0c4fa02fa864c18cfcdbb258b12dc6d4}\label{_l_i_c_8cpp_a0c4fa02fa864c18cfcdbb258b12dc6d4}} 
\index{LIC.cpp@{LIC.cpp}!get\_vector\_truth@{get\_vector\_truth}}
\index{get\_vector\_truth@{get\_vector\_truth}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{get\_vector\_truth()}{get\_vector\_truth()}}
{\footnotesize\ttfamily void get\+\_\+vector\+\_\+truth (\begin{DoxyParamCaption}\item[{int}]{xx,  }\item[{int}]{yy,  }\item[{float \&}]{vx,  }\item[{float \&}]{vy }\end{DoxyParamCaption})}



set the values vx and vy of the vector field from the encoded texture array data\+\_\+img and assign it to vx, vy input 


\begin{DoxyParams}{Parameters}
{\em xx} & x value on the data\+\_\+img texture \\
\hline
{\em yy} & y value on the data\+\_\+img texture \\
\hline
{\em vx} & the resulting vx value after decoding \\
\hline
{\em vy} & the resulting vy value after decoding \\
\hline
\end{DoxyParams}


Definition at line 40 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a7104e8c3b0a2062c3c6685d5bf6ce97a}\label{_l_i_c_8cpp_a7104e8c3b0a2062c3c6685d5bf6ce97a}} 
\index{LIC.cpp@{LIC.cpp}!getAbsoluteDiff2Angles@{getAbsoluteDiff2Angles}}
\index{getAbsoluteDiff2Angles@{getAbsoluteDiff2Angles}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{getAbsoluteDiff2Angles()}{getAbsoluteDiff2Angles()}}
{\footnotesize\ttfamily double get\+Absolute\+Diff2\+Angles (\begin{DoxyParamCaption}\item[{const double}]{x,  }\item[{const double}]{y }\end{DoxyParamCaption})}



Get the absolute diff between two angles. 


\begin{DoxyParams}{Parameters}
{\em x} & angle 1 \\
\hline
{\em y} & angle 2 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
double abs difference between two angles 
\end{DoxyReturn}


Definition at line 53 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_ac2ee8e46d8503c2a0549b53e0ff561aa}\label{_l_i_c_8cpp_ac2ee8e46d8503c2a0549b53e0ff561aa}} 
\index{LIC.cpp@{LIC.cpp}!init\_grids@{init\_grids}}
\index{init\_grids@{init\_grids}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{init\_grids()}{init\_grids()}}
{\footnotesize\ttfamily void init\+\_\+grids (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



main function for setting up critical values of the vector field reconstruction process It initializes average error values, the reconstructed vector field values, and begin the vector field construction process 



Definition at line 963 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a257bc330e36ebc0af5866cfc0017799b}\label{_l_i_c_8cpp_a257bc330e36ebc0af5866cfc0017799b}} 
\index{LIC.cpp@{LIC.cpp}!interpolate\_grid@{interpolate\_grid}}
\index{interpolate\_grid@{interpolate\_grid}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{interpolate\_grid()}{interpolate\_grid()}}
{\footnotesize\ttfamily void interpolate\+\_\+grid (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



set the values of the interpolated grid based on the original grid 



Definition at line 1105 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_ad1281b52ebf50b61510faeec9030a32d}\label{_l_i_c_8cpp_ad1281b52ebf50b61510faeec9030a32d}} 
\index{LIC.cpp@{LIC.cpp}!interpolate\_streamline@{interpolate\_streamline}}
\index{interpolate\_streamline@{interpolate\_streamline}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{interpolate\_streamline()}{interpolate\_streamline()}}
{\footnotesize\ttfamily int interpolate\+\_\+streamline (\begin{DoxyParamCaption}\item[{float}]{xx,  }\item[{float}]{yy,  }\item[{float \&}]{vx,  }\item[{float \&}]{vy,  }\item[{float}]{radar }\end{DoxyParamCaption})}



reconstruct the vector value of the point (xx,yy) on the vector field by using the Adaptive Weighed Sum method 


\begin{DoxyParams}{Parameters}
{\em xx} & x coord of the point on the vector field \\
\hline
{\em yy} & y coord of the point on the vector field \\
\hline
{\em vx} & the resulting vx value after reconstruction \\
\hline
{\em vy} & the resulting vy value after reconstruction \\
\hline
{\em radar} & the radar diameter to scan for surrounding streamline nodes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int how many streamline nodes where found within the radar range, used for recursion. If the result is too few then increase radar range and vice versa 
\end{DoxyReturn}


Definition at line 301 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_aaa8315a9072863e2a64b9f77b1036d54}\label{_l_i_c_8cpp_aaa8315a9072863e2a64b9f77b1036d54}} 
\index{LIC.cpp@{LIC.cpp}!interpolate\_streamline\_adv@{interpolate\_streamline\_adv}}
\index{interpolate\_streamline\_adv@{interpolate\_streamline\_adv}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{interpolate\_streamline\_adv()}{interpolate\_streamline\_adv()}}
{\footnotesize\ttfamily void interpolate\+\_\+streamline\+\_\+adv (\begin{DoxyParamCaption}\item[{float}]{xx,  }\item[{float}]{yy,  }\item[{float \&}]{vx,  }\item[{float \&}]{vy,  }\item[{float}]{radar }\end{DoxyParamCaption})}



T\+O\+DO\+: figure out what this method does. 


\begin{DoxyParams}{Parameters}
{\em xx} & \\
\hline
{\em yy} & \\
\hline
{\em vx} & \\
\hline
{\em vy} & \\
\hline
{\em radar} & \\
\hline
\end{DoxyParams}


Definition at line 355 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_af11e7e720b8967b5e5e3d65a07bb4ee8}\label{_l_i_c_8cpp_af11e7e720b8967b5e5e3d65a07bb4ee8}} 
\index{LIC.cpp@{LIC.cpp}!interpolate\_streamline\_raycast@{interpolate\_streamline\_raycast}}
\index{interpolate\_streamline\_raycast@{interpolate\_streamline\_raycast}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{interpolate\_streamline\_raycast()}{interpolate\_streamline\_raycast()}}
{\footnotesize\ttfamily int interpolate\+\_\+streamline\+\_\+raycast (\begin{DoxyParamCaption}\item[{float}]{xx,  }\item[{float}]{yy,  }\item[{float \&}]{vx,  }\item[{float \&}]{vy,  }\item[{float}]{radar }\end{DoxyParamCaption})}



poor man\textquotesingle{}s raycast implementation, only check four offset points from the desired vector field point. Not very effective 


\begin{DoxyParams}{Parameters}
{\em xx} & x coord of the point on the vector field \\
\hline
{\em yy} & y coord of the point on the vector field \\
\hline
{\em vx} & the resulting vx value after reconstruction \\
\hline
{\em vy} & the resulting vy value after reconstruction \\
\hline
{\em radar} & the radar diameter to scan for surrounding streamline nodes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int how many streamline nodes where found within the radar range, used for recursion. If the result is too few then increase radar range and vice versa 
\end{DoxyReturn}


Definition at line 542 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a7edd5969d04f7427730ca11229696d49}\label{_l_i_c_8cpp_a7edd5969d04f7427730ca11229696d49}} 
\index{LIC.cpp@{LIC.cpp}!interpolate\_streamline\_selective@{interpolate\_streamline\_selective}}
\index{interpolate\_streamline\_selective@{interpolate\_streamline\_selective}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{interpolate\_streamline\_selective()}{interpolate\_streamline\_selective()}}
{\footnotesize\ttfamily int interpolate\+\_\+streamline\+\_\+selective (\begin{DoxyParamCaption}\item[{float}]{xx,  }\item[{float}]{yy,  }\item[{float \&}]{vx,  }\item[{float \&}]{vy,  }\item[{float}]{radar }\end{DoxyParamCaption})}



reconstruct the vector value of the point (xx,yy) on the vector field by using the Selective Weighed Sum method, this method provides the most reliable reconstruction it first uses the nearest streamline node\textquotesingle{}s vector value as the base, then it finds the next closest node and compare the vector value, if the difference is below the average threshold then it computes the weighted sum between two nodes, if the diff is too large then it discard the second node. The process is repeated untill all nodes within radar range is processed 


\begin{DoxyParams}{Parameters}
{\em xx} & x coord of the point on the vector field \\
\hline
{\em yy} & y coord of the point on the vector field \\
\hline
{\em vx} & the resulting vx value after reconstruction \\
\hline
{\em vy} & the resulting vy value after reconstruction \\
\hline
{\em radar} & the radar diameter to scan for surrounding streamline nodes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int how many streamline nodes where found within the radar range, used for recursion. If the result is too few then increase radar range and vice versa 
\end{DoxyReturn}


Definition at line 222 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a13988a42b45be1a5cb4160c82965f26f}\label{_l_i_c_8cpp_a13988a42b45be1a5cb4160c82965f26f}} 
\index{LIC.cpp@{LIC.cpp}!interpolate\_streamline\_simple@{interpolate\_streamline\_simple}}
\index{interpolate\_streamline\_simple@{interpolate\_streamline\_simple}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{interpolate\_streamline\_simple()}{interpolate\_streamline\_simple()}}
{\footnotesize\ttfamily int interpolate\+\_\+streamline\+\_\+simple (\begin{DoxyParamCaption}\item[{float}]{xx,  }\item[{float}]{yy,  }\item[{float \&}]{vx,  }\item[{float \&}]{vy,  }\item[{float}]{radar }\end{DoxyParamCaption})}



reconstruct the vector value of a point by doing a simple weighted sum of all nearby streamline points. This is the least accurate method 


\begin{DoxyParams}{Parameters}
{\em xx} & x coord of the point on the vector field \\
\hline
{\em yy} & y coord of the point on the vector field \\
\hline
{\em vx} & the resulting vx value after reconstruction \\
\hline
{\em vy} & the resulting vy value after reconstruction \\
\hline
{\em radar} & the radar diameter to scan for surrounding streamline nodes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int how many streamline nodes where found within the radar range, used for recursion. If the result is too few then increase radar range and vice versa 
\end{DoxyReturn}


Definition at line 471 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_acb7213fbb6217a949fb35df63fbd9f8c}\label{_l_i_c_8cpp_acb7213fbb6217a949fb35df63fbd9f8c}} 
\index{LIC.cpp@{LIC.cpp}!lazy\_seeding@{lazy\_seeding}}
\index{lazy\_seeding@{lazy\_seeding}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{lazy\_seeding()}{lazy\_seeding()}}
{\footnotesize\ttfamily void lazy\+\_\+seeding (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



uniform streamline seeding method that stops tracing the streamline when it gets too cloest to another streamline 



Definition at line 1139 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a230d5b4c351c593b74f50010d1e395e4}\label{_l_i_c_8cpp_a230d5b4c351c593b74f50010d1e395e4}} 
\index{LIC.cpp@{LIC.cpp}!min\_distance\_to\_all\_steamlines@{min\_distance\_to\_all\_steamlines}}
\index{min\_distance\_to\_all\_steamlines@{min\_distance\_to\_all\_steamlines}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{min\_distance\_to\_all\_steamlines()}{min\_distance\_to\_all\_steamlines()}}
{\footnotesize\ttfamily float min\+\_\+distance\+\_\+to\+\_\+all\+\_\+steamlines (\begin{DoxyParamCaption}\item[{float}]{x,  }\item[{float}]{y }\end{DoxyParamCaption})}



get the minimum distance between the current point and the nearest point\textquotesingle{}s streamline 


\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em y} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
float min dist 
\end{DoxyReturn}


Definition at line 67 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_ac87cae5571d56b451db2f2018d42b677}\label{_l_i_c_8cpp_ac87cae5571d56b451db2f2018d42b677}} 
\index{LIC.cpp@{LIC.cpp}!min\_distance\_to\_steamline@{min\_distance\_to\_steamline}}
\index{min\_distance\_to\_steamline@{min\_distance\_to\_steamline}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{min\_distance\_to\_steamline()}{min\_distance\_to\_steamline()}}
{\footnotesize\ttfamily float min\+\_\+distance\+\_\+to\+\_\+steamline (\begin{DoxyParamCaption}\item[{float}]{x,  }\item[{float}]{y,  }\item[{std\+::vector$<$ \mbox{\hyperlink{structnode}{node}} $>$ $\ast$}]{streamline }\end{DoxyParamCaption})}



get the minimum distance to a specific streamline from a point x,y 


\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em y} & \\
\hline
{\em streamline} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
float min distance to streamline 
\end{DoxyReturn}


Definition at line 168 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a21f961c29f18e6578f3272738013ac9f}\label{_l_i_c_8cpp_a21f961c29f18e6578f3272738013ac9f}} 
\index{LIC.cpp@{LIC.cpp}!min\_node\_to\_steamline@{min\_node\_to\_steamline}}
\index{min\_node\_to\_steamline@{min\_node\_to\_steamline}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{min\_node\_to\_steamline()}{min\_node\_to\_steamline()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structnode}{node}}$\ast$ min\+\_\+node\+\_\+to\+\_\+steamline (\begin{DoxyParamCaption}\item[{float}]{x,  }\item[{float}]{y,  }\item[{std\+::vector$<$ \mbox{\hyperlink{structnode}{node}} $>$ $\ast$}]{streamline }\end{DoxyParamCaption})}



get the closest node to a specific streamline from a point 


\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em y} & \\
\hline
{\em streamline} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
node$\ast$ the closest node of that streamline 
\end{DoxyReturn}


Definition at line 188 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_aa2300c2a0e0a396711be37f08d412eef}\label{_l_i_c_8cpp_aa2300c2a0e0a396711be37f08d412eef}} 
\index{LIC.cpp@{LIC.cpp}!render\_vec\_img@{render\_vec\_img}}
\index{render\_vec\_img@{render\_vec\_img}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{render\_vec\_img()}{render\_vec\_img()}}
{\footnotesize\ttfamily void render\+\_\+vec\+\_\+img (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_polyhedron}{Polyhedron}} $\ast$}]{this\+\_\+poly }\end{DoxyParamCaption})}



render the vector field onto a texture for scaling to 512x512 


\begin{DoxyParams}{Parameters}
{\em this\+\_\+poly} & the read vetor field \\
\hline
\end{DoxyParams}


Definition at line 879 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_acdfb182730d63b03a08745835c5106d4}\label{_l_i_c_8cpp_acdfb182730d63b03a08745835c5106d4}} 
\index{LIC.cpp@{LIC.cpp}!trace\_streamline@{trace\_streamline}}
\index{trace\_streamline@{trace\_streamline}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{trace\_streamline()}{trace\_streamline()}}
{\footnotesize\ttfamily void trace\+\_\+streamline (\begin{DoxyParamCaption}\item[{int}]{xx,  }\item[{int}]{yy,  }\item[{int}]{enhance }\end{DoxyParamCaption})}



trace the streamlet to produce the L\+IC texture 


\begin{DoxyParams}{Parameters}
{\em xx} & start tracing from this x \\
\hline
{\em yy} & start tracing from this y \\
\hline
{\em enhance} & use the enhanced L\+IC texture or not (0 or 1) \\
\hline
\end{DoxyParams}


Definition at line 691 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a6e812df5b7c609971288722b7bd2ea71}\label{_l_i_c_8cpp_a6e812df5b7c609971288722b7bd2ea71}} 
\index{LIC.cpp@{LIC.cpp}!trace\_streamline\_custom@{trace\_streamline\_custom}}
\index{trace\_streamline\_custom@{trace\_streamline\_custom}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{trace\_streamline\_custom()}{trace\_streamline\_custom()}}
{\footnotesize\ttfamily std\+::vector$<$\mbox{\hyperlink{structnode}{node}}$>$$\ast$ trace\+\_\+streamline\+\_\+custom (\begin{DoxyParamCaption}\item[{int}]{xx,  }\item[{int}]{yy,  }\item[{float}]{min\+\_\+dis }\end{DoxyParamCaption})}



trace the streamline based on the given point, will stop when it gets too close to another streamline 


\begin{DoxyParams}{Parameters}
{\em xx} & start tracing from this x \\
\hline
{\em yy} & start tracing from this y \\
\hline
{\em min\+\_\+dis} & the min distance to another streamline to stop \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$node$>$$\ast$ the streamline 
\end{DoxyReturn}


Definition at line 572 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_ae7ef4a9db8b17caa2c8b6120134e8091}\label{_l_i_c_8cpp_ae7ef4a9db8b17caa2c8b6120134e8091}} 
\index{LIC.cpp@{LIC.cpp}!trace\_streamline\_old@{trace\_streamline\_old}}
\index{trace\_streamline\_old@{trace\_streamline\_old}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{trace\_streamline\_old()}{trace\_streamline\_old()}}
{\footnotesize\ttfamily void trace\+\_\+streamline\+\_\+old (\begin{DoxyParamCaption}\item[{int}]{xx,  }\item[{int}]{yy }\end{DoxyParamCaption})}



obsolete L\+IC streamline tracing method 


\begin{DoxyParams}{Parameters}
{\em xx} & \\
\hline
{\em yy} & \\
\hline
\end{DoxyParams}


Definition at line 818 of file L\+I\+C.\+cpp.



\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{_l_i_c_8cpp_a10e0b1ea070ec97ad7b40ac0d6037d6c}\label{_l_i_c_8cpp_a10e0b1ea070ec97ad7b40ac0d6037d6c}} 
\index{LIC.cpp@{LIC.cpp}!angle\_diff\_counter@{angle\_diff\_counter}}
\index{angle\_diff\_counter@{angle\_diff\_counter}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{angle\_diff\_counter}{angle\_diff\_counter}}
{\footnotesize\ttfamily int angle\+\_\+diff\+\_\+counter = 0}



Definition at line 344 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a0afaee52a9e947535072c3a099af48ff}\label{_l_i_c_8cpp_a0afaee52a9e947535072c3a099af48ff}} 
\index{LIC.cpp@{LIC.cpp}!avg\_angle\_diff@{avg\_angle\_diff}}
\index{avg\_angle\_diff@{avg\_angle\_diff}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{avg\_angle\_diff}{avg\_angle\_diff}}
{\footnotesize\ttfamily float avg\+\_\+angle\+\_\+diff = 0}



Definition at line 343 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a0e12e73800927bbae62911d176354832}\label{_l_i_c_8cpp_a0e12e73800927bbae62911d176354832}} 
\index{LIC.cpp@{LIC.cpp}!STREAMLINE\_LENGTH@{STREAMLINE\_LENGTH}}
\index{STREAMLINE\_LENGTH@{STREAMLINE\_LENGTH}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{STREAMLINE\_LENGTH}{STREAMLINE\_LENGTH}}
{\footnotesize\ttfamily int S\+T\+R\+E\+A\+M\+L\+I\+N\+E\+\_\+\+L\+E\+N\+G\+TH = 500}



Definition at line 562 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_ad369ab96ebde4b09102c400562c9ada2}\label{_l_i_c_8cpp_ad369ab96ebde4b09102c400562c9ada2}} 
\index{LIC.cpp@{LIC.cpp}!v\_diff\_average@{v\_diff\_average}}
\index{v\_diff\_average@{v\_diff\_average}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{v\_diff\_average}{v\_diff\_average}}
{\footnotesize\ttfamily float v\+\_\+diff\+\_\+average = 0}



trackers for average difference in vector values 



Definition at line 208 of file L\+I\+C.\+cpp.

\mbox{\Hypertarget{_l_i_c_8cpp_a48dc64fa95d54b85644d5c92c38f6066}\label{_l_i_c_8cpp_a48dc64fa95d54b85644d5c92c38f6066}} 
\index{LIC.cpp@{LIC.cpp}!v\_diff\_counter@{v\_diff\_counter}}
\index{v\_diff\_counter@{v\_diff\_counter}!LIC.cpp@{LIC.cpp}}
\doxysubsubsection{\texorpdfstring{v\_diff\_counter}{v\_diff\_counter}}
{\footnotesize\ttfamily float v\+\_\+diff\+\_\+counter = 0}



Definition at line 208 of file L\+I\+C.\+cpp.

